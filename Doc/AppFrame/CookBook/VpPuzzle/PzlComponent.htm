<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
		
		<title></title><meta name="GENERATOR" content="Microsoft Visual Studio .NET 7.1">
		<meta name="vs_targetSchema" content="http://schemas.microsoft.com/intellisense/ie5">
		<style type="text/css">/*<![CDATA[*/ .source-vip .de1, .source-vip .de2 {font-family: Verdana, Arial, sans-serif; color: black}
	.source-vip {font-family: Verdana, Arial, sans-serif; color: black; font-size: 95%;}
	.source-vip .head {}
	.source-vip .foot {}
	.source-vip .imp {font-weight: bold; color: red;}
	.source-vip .ln-xtra {color: #cc0; background-color: #ffc;}
	.source-vip li {font-family: Verdana, Arial, sans-serif; color: black; font-weight: normal; font-style: normal;}
	.source-vip li.li2 {font-weight: bold;}
	.source-vip .kw1 {color: #808000;}
	.source-vip .kw2 {color: #333399;}
	.source-vip .kw3 {color: #800080;}
	.source-vip .co1 {color: #AA77BD}
	.source-vip .coMULTI {color: #AA77BD}
	.source-vip .es0 {color: #008080;}
	.source-vip .br0 {color: #000000;}
	.source-vip .st0 {color: #00B7B7;}
	.source-vip .nu0 {color: #0000FF;}
	.source-vip .re0 {color: #008000;}
	.source-vip .re1 {color: #808000;}
	.source-vip .re2 {color: #333399;}
	/*]]>*/ 
		</style></head>

	<body>
		<div id="globalWrapper">
			<div id="column-content">
				<div id="content"><a id="top" name="top"></a>
					<h1 class="firstHeading">Pzl-Component</h1>
					<p>Copyright 
							(C) 2007-2008. Prolog Development Center SPb.
					</p>
					<div>
						<table class="toc" id="toc" summary="Ñîäåðæàíèå">
							<tbody><tr>
							</tr>
						</tbody></table>
					</div>
					<h2><span class="mw-headline">The necessary conditions to acknowledge the class as the 
							pzl-component</span></h2><p><span class="mw-headline"></span>Any class, which creates an objects (which has an interface), may be 
						acknowledged as the component if:
					</p>
					
					<div>
						<ol>
							<li>
							The name of the interface and the name of the class are different;
							</li><li>
								The interface of the class supports the interface <i>pzlComponent</i>;
							</li><li>
								The interface of the class includes the constants declarations:
							</li>
						</ol>
					</div>
					<ol>
					<ol>
						<li>
							<i>componentID_C</i> of <i>pzlDomains::entityUID_D</i>
						type
						</li><li>
							<i>componentAlias_C</i> of <i>string</i>
						type
						</li><li>
							<i>componentRunAble_C</i> of <i>core::booleanInt</i>
						type
						</li><li>
							<i>componentMetaInfo_C</i> of <i>core::namedValue*</i>. type
						</li><li>
							<i>ñomponentDescriptor_C</i> of <i>pzlDomains::pzlComponentInfo_D</i> type
						</li>
					</ol>
					<li>
						The declaration of the class contains the only constructor <i>new(object 
							ExistingObject)</i>;
					</li><li>
						The implementation of the class derives the class <i>pzlComponent</i>;
					</li><li>
						The package declarations file (.PH) of the class includes the file <i>"System\Packs\pzlcomponent\pzlcomponent.ph".</i>
					</li>
					</ol>
					<p>The examples of the parts of the component declarations and implementations are 
						shown below.
					</p>
					<p><b>Class declaration</b>
					</p>
					<dl>
						<dd>
							Contains the only constructor <i>new:(object UsingObject)</i>. The name of the 
							interface different from the name of the class.
						</dd>
					</dl>
					<div dir="ltr"><pre class="source-vip" style="font-size: 95%; color: black; font-family: Verdana,Arial,sans-serif;"><span class="re1">class</span> componentExample:<span class="me1">iComponentExample</span>
&nbsp;
<span class="kw1">constructors</span>
  new:<span class="me1"><span class="br0">(</span>object</span> <span class="re0">UsingObject</span><span class="br0">)</span>.<br>&nbsp;<br><span class="re1">end class</span></pre>
					</div>
					<p><b>Interface of the Class</b>
					</p>
					<dl>
						<dd>
							Contains the qualifiyer <i><b>supports pzlComponent</b></i> and the declaration 
							of constants
							<ul>
								<li>
								componentID_C
								</li><li>
								componentAlias_C
								</li><li>
								componentRunAble_C=b_True
								</li><li>
								componentMetaInfo_C
								</li><li>
									componentDescriptor_C
								</li>
							</ul>
						</dd>
					</dl>
					<div dir="ltr"><pre class="source-vip" style="font-size: 95%; color: black; font-family: Verdana,Arial,sans-serif;"><span class="re1">interface</span> iComponentExample<br>  <span class="kw1">supports</span> pzlComponent<br>&nbsp;<br><span class="kw1">open</span> core<br><span class="kw1">constants</span>
  componentDescriptor_C:<span class="me1">pzlDomains</span>::<span class="me1">pzlComponentInfo_D</span>=pzlDomains::<span class="me1">pzlComponentInfo</span>
    <span class="br0">(</span>
    componentAlias_C,
    componentID_C,
    componentRunAble_C,
    componentMetaInfo_C
    <span class="br0">)</span>.<br>  componentID_C:<span class="me1">pzlDomains</span>::<span class="me1">entityUID_D</span>=pzlDomains::<span class="me1">str</span><span class="br0">(</span><span class="st0">"ComponentExample"</span><span class="br0">)</span>.<br>  componentAlias_C=<span class="st0">"ExampleOfTheComponent"</span>.<br>  componentRunAble_C=b_True.<br>  componentMetaInfo_C:<span class="me1">namedValue_List</span>=<span class="br0">[</span><span class="br0">]</span>.<br>&nbsp;<br><span class="kw1">predicates</span>
  show:<span class="me1"><span class="br0">(</span></span><span class="br0">)</span>.<br>&nbsp;<br><span class="re1">end interface</span> iComponentExample</pre>
					</div>
					<p><b>Class Implementation</b>
					</p>
					<dl>
						<dd>
							Contains the inharitance statement <i><b>inherits pzlComponent</b></i> and also 
							contains the clause for the constructor <i><b>new(UsingObject)</b></i>
						</dd>
					</dl>
					<div dir="ltr"><pre class="source-vip" style="font-size: 95%; color: black; font-family: Verdana,Arial,sans-serif;"><span class="re1">implement</span> componentExample<br>    <span class="kw1">inherits</span> pzlComponent<br>&nbsp;<br><span class="kw1">clauses</span>
  new<span class="br0">(</span><span class="re0">UsingObject</span><span class="br0">)</span>:-<br>    ...<br>&nbsp;<br><span class="kw1">clauses</span>
  show<span class="br0">(</span><span class="br0">)</span>:-<br>  ...<br><span class="re1">end implement</span> componentExample</pre>
					</div>
					<p><b>The Package Header File</b> ComponentExample.PH
					</p>
					<dl>
						<dd>
							Contains the include file '<b>PzlComponent.ph</b><i> statement</i>
						</dd>
					</dl>
					<div dir="ltr"><pre class="source-vip" style="font-size: 95%; color: black; font-family: Verdana,Arial,sans-serif;">#requires ...<br><span class="kw3">#include</span> <span class="st0">@"System\Packs\pzlcomponent\pzlcomponent.ph"</span>
&nbsp;
<span class="kw3">#include</span> <span class="st0">@"pfc\core.ph"</span></pre>
					</div>
					<a name="Interface_pzlComponent"></a>
					<h1><span class="mw-headline">Interface pzlComponent</span></h1>
					<p>The Interface pzlComponent corresponds to the class pzlComponent and this makes 
						the class to be the pzl-component. The class PzlComponent , binds the component 
						with other parts of the pzl-system. Also Interface PzlComponent helps in 
						getting the information regarding the component.
					</p>
					<p>The following predicates supported by the Pzl-system
					</p>
					<ul>
						<li>
						getContainerVersion() - returns the information regarding the version of the 
						container, where the given component placed
						</li><li>
						getContainerName() - returns the name of the file, where the given component 
						placed
						</li><li>
							getClassInfo(className,classVersion) - returns the name and the version of the 
							class pzlComponent
						</li>
					</ul>
					<p>The other predicates of the interface PzlComponent:
					</p>
					<ul>
						<li>
						getComponentVersion()-&gt; string
						</li><li>
						getComponentID() -&gt; entityUID_D
						</li><li>
						getComponentAlias() -&gt; string
						</li><li>
						getComponentMetaInfo() -&gt; namedValue*
						</li><li>
							release
						</li>
					</ul>
					<p>must be defined in the implementation of the base class of the component. 
						Otherwise the exception is generated while the appropriate call.
					</p>
					<h1><a name="Predefined_constants_of_the_base_interface_of_the_pzl-component"></a><span class="mw-headline"><span style="font-weight: bold;"></span>Predefined constants of the base interface of the 
							pzl-component</span>&nbsp;</h1><h2><a name="Constant_componentID_.D0.A1"></a><span class="mw-headline">Constant componentID_C</span></h2><p>The constant componentID_C defines the identifier of the component, which must 
						be unique if possible in the global sense. It means that two programs in the 
						global information space (and we do not even mention one computer), which use 
						the component with the same identifier, may be sure that they use exactly the 
						same pzl-component. This may be reached by the using of the Microsoft company 
						approach to identify MSCOM components. To fit this the pzl-technology uses the 
						data structure with the functor uid:
					</p>
					
					
					<div dir="ltr"><pre class="source-vip" style="font-size: 95%; color: black; font-family: Verdana,Arial,sans-serif;">uid<span class="br0">(</span>
  core::<span class="me1">unsigned32</span> <span class="re0">Unsigned</span>,<br>  core::<span class="me1">unsigned16</span> <span class="re0">Short1</span>,<br>  core::<span class="me1">unsigned16</span> <span class="re0">Short2</span>,<br>  core::<span class="me1">unsigned8</span> <span class="re0">Byte1</span>,<br>  core::<span class="me1">unsigned8</span> <span class="re0">Byte2</span>,<br>  core::<span class="me1">unsigned8</span> <span class="re0">Byte3</span>,<br>  core::<span class="me1">unsigned8</span> <span class="re0">Byte4</span>,<br>  core::<span class="me1">unsigned8</span> <span class="re0">Byte5</span>,<br>  core::<span class="me1">unsigned8</span> <span class="re0">Byte6</span>,<br>  core::<span class="me1">unsigned8</span> <span class="re0">Byte7</span>,<br>  core::<span class="me1">unsigned8</span> <span class="re0">Byte8</span><span class="br0">)</span>.</pre>
					</div>
					<p>and this is in reality the analogue of the structure core::nativeGuid of the 
						Visual Prolog system. The identifier componentID_C used in two cases:
					</p>
					<ul>
						<li>
						It is the identifier, which is used to register the component in the Windows 
						registry or(and) in the user controlled component registry file
						</li><li>
							It is the identifier, which is used to register the component in the 
							pzl-container
						</li>
					</ul>
					<p>Because of the identifier in the form uid is combersome sequence of letters and 
						figures, it is not convenient to use it while the learning of the 
						pzl-technology.
					</p>
					<p>To make the learning process easier, there is another way to represent the 
						identifier - the string form str(string). Naturally, the uniqueness is not 
						provided in that case, but for the educational purposes we may sacrifice the 
						glibal uniqueness and to control the uniaueness of the identifier on the given 
						computer only.
					</p>
					<p>As the result we get two alternative forms to define identifier in the domain 
						entityUID_D declaration:
					</p>
					<div dir="ltr"><pre class="source-vip" style="font-size: 95%; color: black; font-family: Verdana,Arial,sans-serif;">entityUID_D=<br>  str<span class="br0">(</span>string<span class="br0">)</span>;<br>  uid<span class="br0">(</span>unsined16,...<span class="br0">)</span>.</pre>
					</div>
					<h3><a name="Constant_componentAlias_C"></a><span class="mw-headline"><span style="font-weight: bold;"></span>Constant componentAlias_C</span></h3><p>Together with the unique identifier, the pzl-technology gives the possbility to 
						assign to a component the string name (Alias). To do so the name must be 
						assigned to the constant ComponentAlias_C. The uniqueness of this name is not 
						the hard demand.
					</p>
					
					<p>You may create many text editors with the differenct features, which support the 
						same interfaces. Each if these text editors will have the unique identifier of 
						the entityUID_D type and possibly each of them will have it's own name of the 
						base class. But all of them will have the same Alias (say "Text Editor". Then 
						your applicaion (not knowing the name of the class), may use the name "Text 
						Editor" while the creation of the instance of the Editor. The component, wich 
						is registered at your computer this moment will be used to create an 
						appropriate object. Changing the registration of the Editor you may use another 
						Editor with the other features.
					</p>
					<p>You must understand that all the collisions çêùìùñôåóâ by uniqueness of the 
						aliases must be resolved by the programmer.
					</p>
					<p>The Alias may be used by many tools of the pzl-technology to identify components 
						on the screen or in the error messages.
					</p>
					<h3><a name="Constant_componentRunable_C"></a><span class="mw-headline">Constant componentRunable_C</span></h3>
					<p>The constant componentRunable_C informs about the possibility for the given 
						component to run independently by calling the predicate <b>spbRun:(string UserInfo)</b>. 
						The predicate spbRun is declared in the interface spbRun (file 
						VpPuZzle/Interfaces/spbRun.i).
					</p>
					<p>The component must support the interface spbRun, if the possibility to call the 
						predicate spbRun expected.
					</p>
					<p>If the component supports the interface spbRun then the constant 
						componentRunable_C must have the value core::b_true otherwise it must have 
						value core::b_false.
					</p>
					<p>Predicate spbRun is the only one predicate, which may be supported by the 
						component at least and the name of this predicate is known.
					</p>
					<p>The predicate spbRun has the single input parameter UserInfo of string type. The 
						meaning of the parameter may be defined by the developer of the pzl-component.
					</p>
					<p>If the given component may be invoked using the predicate spbRun, then it means, 
						that the applicaion has the conditions that give that component the possbility 
						to run.
					</p>
					<p>It is similar a little to the declaration GOAL - the initial point of the 
						program. The only difference is that in case of the predicate spbRun it may be 
						invoked or maybe not.
					</p>
					<p>If the applicaion based on the User Interface (pfc/GUI èëè pfc/VPI), then the 
						possibility to run using the predicate spbRun may lead to the creation of the 
						form or the creation of the dialog, and this graphical entity will do something 
						(not necessery useful).
					</p>
					<p>If the user interface is not used, then the predicate spbRun may be used by the 
						programmer for some other purposes.
					</p>
					<p>The predicate <b>spbRun:(string UserInfo)</b> is declared in the interface 
						spbRun, and it is the only predicate of that interface. If the component 
						supports the interface spbRun, then it must be declared in the standard way:
					</p>
					<div dir="ltr"><pre class="source-vip" style="font-size: 95%; color: black; font-family: Verdana,Arial,sans-serif;"><span class="re1">interface</span> componentInterface<br>  <span class="kw1">supports</span> pzlComponent<br>  <span class="kw1">supports</span> spbRun<br>&nbsp;<br><span class="kw1">constants</span>
...
  <span class="re0">ComponentRunable_C</span> = b_true.<br>...<br><span class="re1">end interface</span> componentInterface</pre>
					</div>
					<p>I may be the case, when the one of the interfaces, which supported by the base 
						component interface must support the interface spbRun as it is shown below
					</p>
					<div dir="ltr"><pre class="source-vip" style="font-size: 95%; color: black; font-family: Verdana,Arial,sans-serif;"><span class="re1">interface</span> componentInterface<br>  <span class="kw1">supports</span> pzlComponent<br>  <span class="kw1">supports</span> textEditor<br>&nbsp;<br><span class="kw1">constants</span>
...
  componentRunable_C = b_true.
...
<span class="re1">end interface</span> componentInterface<br>&nbsp;<br><span class="re1">interface</span> textEditor<br>  <span class="kw1">supports</span> spbRun<br>...<br><span class="re1">end interface</span> textEditor</pre>
					</div>
					<h3><a name="Constant_componentMetaInfo_C"></a><span class="mw-headline"><span style="font-weight: bold;"></span>Constant componentMetaInfo_C</span></h3>
					<p>The constant componentMetaInfo_C belongs to the type core::namedValue* and it 
						may contain the list of named values, which have the sense, relative to the 
						given component (meta information regarding the component).
					</p>
					<p>Pzl-system does nothing with this information. This information may be requested 
						from the container and from the component by programmer.
					</p>
					<p>If there is no metainformation regarding the component, the constant 
						componentMetaInfo_C must be defined anyway (as the empty list).
					</p>
					<div dir="ltr"><pre class="source-vip" style="font-size: 95%; color: black; font-family: Verdana,Arial,sans-serif;"><span class="kw1">constants</span>
  componentMetaInfo_C = <span class="br0">[</span><span class="br0">]</span>.</pre>
					</div>
					<h3><a name="Constant_.D1.81omponentDescriptor_C"></a><span class="mw-headline"><span style="font-weight: bold;"></span>Constant componentDescriptor_C</span></h3>
					<p>The constant ñomponentDescriptor_C integrates the most important features of the 
						component defined by the constants listed above:
					</p>
					<ul>
						<li>
						ComponentID_C,
						</li><li>
						ComponentAlias_C,
						</li><li>
						ComponentRunable_C
						</li><li>
							ComponentMetainfo_C
						</li>
					</ul>
					<p>The constant ñomponentDescriptor_C corresponds to the domain 
						pzlDomains::pzlComponentInfo_D, declared in in the interface pzlDomains (the 
						file VpPuZzle/Domains/pzlDomains.i):
					</p>
					<div dir="ltr"><pre class="source-vip" style="font-size: 95%; color: black; font-family: Verdana,Arial,sans-serif;">pzlComponentInfo_D=pzlComponentInfo<br>  <span class="br0">(</span>
  string <span class="re0">Alias</span>,<br>  entityUID_D <span class="re0">ComponentID</span>,<br>  booleanInt <span class="re0">Runable</span>,<br>  core::<span class="me1">namedValue_List</span> <span class="re0">UserDefinedInfo</span>
  <span class="br0">)</span>.</pre>
					</div>
					<h3><a name="The_pzl-component_description_example"></a><span class="mw-headline"><span style="font-weight: bold;"></span>The pzl-component description example</span></h3>
					<p>In the real component the constants describing the component may look like shown 
						below:
					</p>
					<div dir="ltr"><pre class="source-vip" style="font-size: 95%; color: black; font-family: Verdana,Arial,sans-serif;"><span class="kw1">constants</span>
  componentDescriptor_C:<span class="me1">pzlDomains</span>::<span class="me1">pzlComponentInfo_D</span>=pzlDomains::<span class="me1">pzlComponentInfo</span>
    <span class="br0">(</span>
    componentAlias_C,
    componentID_C,
    componentRunAble_C,
    componentMetaInfo_C
    <span class="br0">)</span>.<br>  componentID_C:<span class="me1">pzlDomains</span>::<span class="me1">entityUID_D</span>=pzlDomains::<span class="me1">str</span><span class="br0">(</span><span class="st0">"ComponentExample"</span><span class="br0">)</span>.<br>  componentAlias_C=<span class="st0">"TheComponentExample"</span>.<br>  componentRunAble_C=b_True.<br>  componentMetaInfo_C:<span class="me1">namedValue_List</span>=<span class="br0">[</span><span class="br0">]</span>.</pre>
					</div>
					<p>or it may look like
					</p>
					<div dir="ltr"><pre class="source-vip" style="font-size: 95%; color: black; font-family: Verdana,Arial,sans-serif;"><span class="kw1">constants</span>
  componentDescriptor_C:<span class="me1">pzlDomains</span>::<span class="me1">pzlComponentInfo_D</span>=pzlDomains::<span class="me1">pzlComponentInfo</span>
    <span class="br0">(</span>
    componentAlias_C,
    componentID_C,
    componentRunAble_C,
    componentMetaInfo_C
    <span class="br0">)</span>.<br>  componentID_C:<span class="me1">pzlDomains</span>::<span class="me1">entityUID_D</span>=<br>    pzlDomains::<span class="me1">uid</span><span class="br0">(</span>0x5701809E,0x0453,0x43A2,0xB1,0x82,0x8F,0xAE,0x2A,0x6B,0xA5,0x63<span class="br0">)</span>.<br>  componentAlias_C=<span class="st0">"PzlAboutDialog"</span>.<br>  componentRunAble_C=b_False.<br>  componentMetaInfo_C:<span class="me1">namedValue_List</span>=<br>    <span class="br0">[</span>
    namedValue<span class="br0">(</span><span class="st0">"CodeExporter"</span>,string<span class="br0">(</span><span class="st0">"AboutExporter"</span><span class="br0">)</span><span class="br0">)</span>
    <span class="br0">]</span>.</pre>
					</div>
					<h1><a name="The_constructor_of_the_component_new:.28object_UsingObject.29"></a><span class="mw-headline"><span style="font-weight: bold;"></span>The constructor of the component new:(object UsingObject)</span></h1>
					<p>The base class of the pzl-componentmust includes the only one constructor, which 
						must have the format <b>new:(object UsingObject)</b>.
					</p>
					<p>Here the parameter UsingObject (which means "with using the object") has no 
						special purpose and it may be used by the author of the pzl-component.
					</p>
					<p>For instance, in case of the component based on the User Interface (GUI) this 
						parameter may be the object of window type, which corresponds to the parent 
						window object. We should have in mind that the call new(ParentWindow) 
						automatically converts the window type to the object type. And the clause of 
						the constructor will get it as the object type. Thus explicite access to this 
						object is not possible.
					</p>
					<p>To access to the object transferred as the parameter, it must be converted to 
						the known type of the initially transferred object.
					</p>
					<p>Let's consider the case when the parent window is transferred and we need to get 
						the height of the window. We must convert the ParentWindowAsObject to the 
						window type:
					</p>
					<div dir="ltr"><pre class="source-vip" style="font-size: 95%; color: black; font-family: Verdana,Arial,sans-serif;"><span class="kw1">clauses</span>
  new<span class="br0">(</span><span class="re0">ParentWindowAsObject</span><span class="br0">)</span>:-<br>    <span class="re0">ParentWindow</span>=convert<span class="br0">(</span>window,<span class="re0">ParentWindowAsObject</span><span class="br0">)</span>,<br>    <span class="re0">WindowHeight</span>=<span class="re0">ParentWindow</span>:<span class="me1">getHeight</span><span class="br0">(</span><span class="br0">)</span>,<br>    ...</pre>
					</div>
					<h2><a name="The_habits_of_use_pzl-components_as__Vip-classes"></a><span class="mw-headline"><span style="font-weight: bold;"></span>The habits of use pzl-components as Vip-classes</span></h2>
					<p>Pzl-components being the usual classes of the Visual Prolog programming system 
						(Vip-classes), doens't need any special way of proramming. Moreover in the real 
						programming there is no difference in the usual Vip-classes and pzl-components. 
						But we must make some notes regarding some details of their creation and their 
						use.
					</p>
					<h2><a name="The_creation_of_the_pzl-component"></a><span class="mw-headline"><span style="font-weight: bold;"></span>The creation of the pzl-component</span></h2>
					<p>It is possible to create the pzl-component in two ways:
					</p>
					<ul>
						<li>
							<a title="Elementary PzlStudio" href="file:///D:%5CPS-Projects%5CSpbSolutions_7%5CVPPuzzle%5CDoc%5CElementary%20PzlStudio.htm#Pzl-Component_creation">
								By the special tools of the pzl-technology</a>
						</li><li>
							By the standard the IDE procedures (<b>not recommended</b>) - see demands <a title="Pzl-Component" href="#The_necessary_conditions_to_acknowledge_the_class_as_the_pzl-component">
								as described above</a>
						</li>
					</ul>
					<h2><a name="The_ways_to_create_an_instance_of_the_component"></a><span class="mw-headline"><span style="font-weight: bold;"></span>The ways to create an instance of the component</span></h2>
					<p>There are three ways to invoke the creation of the instance of the 
						pzl-component:
					</p>
					<ul>
						<li>
						By calling the class constructor new()
						</li><li>
						By calling the predicate newByName() of the pzl class.
						</li><li>
							By calling the predicate newByID() of the pzl class.
						</li>
					</ul>
					<p>The first way looks like
					</p>
					<div dir="ltr"><pre class="source-vip" style="font-size: 95%; color: black; font-family: Verdana,Arial,sans-serif;">... <br><span class="re0">MyClassInstance</span> =myClass::<span class="me1">new</span><span class="br0">(</span><span class="re0">SomeObject</span><span class="br0">)</span>, <br><span class="re0">MyClassInstance</span>:<span class="me1">callNeededPredicate</span><span class="br0">(</span>&#8230;<span class="br0">)</span> <br>...</pre>
					</div>
					<p>It corresponds to the usual VIP rules.
					</p>
					<p>The second way uses Pzl-system explicitly and looks like
					</p>
					<div dir="ltr"><pre class="source-vip" style="font-size: 95%; color: black; font-family: Verdana,Arial,sans-serif;">...<br><span class="re0">MyClassObj</span>=pzl::<span class="me1">newByName</span><span class="br0">(</span>&#8220;MyClass&#8221;,...<span class="br0">)</span>, <br><span class="re0">MyClassInstance</span>=tryConvert<span class="br0">(</span>iMyClass, <span class="re0">MyClassObj</span><span class="br0">)</span>, <br><span class="re0">MyClassInstance</span>:ñallNeededPredicate<span class="br0">(</span>&#8230;<span class="br0">)</span>,</pre>
					</div>
					<p>Here iMyClass is the base interface of the class myClass and &#8220;MyClass&#8221; is the 
						string name (alias) of the class myClass.
					</p>
					<p>The third way also uses Pzl-system explicitly and looks like
					</p>
					<div dir="ltr"><pre class="source-vip" style="font-size: 95%; color: black; font-family: Verdana,Arial,sans-serif;">...<br><span class="re0">MyClassObj</span>=pzl::<span class="me1">newByID</span><span class="br0">(</span>str<span class="br0">(</span>&#8220;MyClass&#8221;<span class="br0">)</span>,...<span class="br0">)</span>, <br><span class="re0">MyClassInstance</span>=tryConvert<span class="br0">(</span>iMyClass, <span class="re0">MyClassObj</span><span class="br0">)</span>, <br><span class="re0">MyClassInstance</span>:ñallNeededPredicate<span class="br0">(</span>&#8230;<span class="br0">)</span>,</pre>
					</div>
					<p>Here iMyClass is the interface of the class myClass, and str(&#8220;MyClass&#8221;) is the 
						string form of the class identifier.
					</p>
					<h2><a name="Acessing_to_other_classes_and_components"></a><span class="mw-headline"><span style="font-weight: bold;"></span>Acessing to other classes and components</span></h2>
					<p>The accessing to other classes and components from the current component does 
						not differ from the usual style of communication with classes and objects. It 
						is needed to have in mind that to communicate with the component in the style 
						like
					</p>
					<div dir="ltr"><pre class="source-vip" style="font-size: 95%; color: black; font-family: Verdana,Arial,sans-serif;">...<br><span class="re0">ComponentObject</span>=componentClass::<span class="me1">new</span><span class="br0">(</span><span class="re0">SomeObject</span><span class="br0">)</span>,<br><span class="re0">ComponentObject</span>:<span class="me1">componentPredicate</span><span class="br0">(</span><span class="re0">Argument1</span>,...<span class="br0">)</span>,<br>...</pre>
					</div>
					<p>the component <strong class="source-vip">componentClass</strong> must be 
						represented in the project by it's class-delegate (proxy).
					</p>
					<p>But for the accessing in the style
					</p>
					<div dir="ltr"><pre class="source-vip" style="font-size: 95%; color: black; font-family: Verdana,Arial,sans-serif;">...<br><span class="re0">ComponentObjectObj</span>=pzl::<span class="me1">newByName</span><span class="br0">(</span><span class="st0">"ComponentAlias"</span>,<span class="re0">Object</span><span class="br0">)</span>,<br><span class="re0">ComponentObject</span>=convert<span class="br0">(</span>componentInterface,<span class="re0">ComponentObjectObj</span><span class="br0">)</span>,<br><span class="re0">ComponentObject</span>:<span class="me1">componentPredicate</span><span class="br0">(</span><span class="re0">Argument1</span>,...<span class="br0">)</span>,<br>...</pre>
					</div>
					<p>or
					</p>
					<div dir="ltr"><pre class="source-vip" style="font-size: 95%; color: black; font-family: Verdana,Arial,sans-serif;">...<br><span class="re0">ComponentObjectObj</span>=pzl::<span class="me1">newByID</span><span class="br0">(</span><span class="re0">ComponentID</span>,<span class="re0">Object</span><span class="br0">)</span>,<br><span class="re0">ComponentObject</span>=convert<span class="br0">(</span>componentInterface,<span class="re0">ComponentObjectObj</span><span class="br0">)</span>,<br><span class="re0">ComponentObject</span>:<span class="me1">componentPredicate</span><span class="br0">(</span><span class="re0">Argument1</span>,...<span class="br0">)</span>,<br>...</pre>
					</div>
					<p>the class-delegate is not needed.
					</p>
					<h2><a name="The_end_of_use"></a><span class="mw-headline"><span style="font-weight: bold;"></span>The end of use</span></h2>
					<p>When the use of the component is complete the all references to the object must 
						be removed. This is the standard way of object handling in VIP and 
						pzl-components have no difference here.
					</p>
					<p>Pzl-containers are unloading automatically, when there is no active objects in 
						it.
					</p>
					<h2><a name="Debugging"></a><span class="mw-headline"><span style="font-weight: bold;"></span>Debugging</span></h2>
					<p>If the pzl-component placed in the main executable applicaion, then the 
						debugging style is the same as the debugging style for the usual vip-classes.
					</p>
					<p>If the pzl-component is placed to the dll-container, then the debugging process 
						must be started from the project of the dll-container. And this is the standard 
						way of debugging the Dll in the Visual Prolog programming system.
					</p>
					<h2><a name="Registration"></a><span class="mw-headline"><span style="font-weight: bold;"></span>Registration</span></h2>
					<p>If some class and pzl-component are placed in the same entity (.EXE or the same 
						DLL), and the calling is made in the form
					</p>
					<div dir="ltr"><pre class="source-vip" style="font-size: 95%; color: black; font-family: Verdana,Arial,sans-serif;">... <br><span class="re0">MyClassInstance</span> =myClass::<span class="me1">new</span><span class="br0">(</span><span class="re0">SomeObject</span><span class="br0">)</span>, <br><span class="re0">MyClassInstance</span>:<span class="me1">callNeededPredicate</span><span class="br0">(</span>&#8230;<span class="br0">)</span> <br>...</pre>
					</div>
					<p>then the registration of the called pzl-component is not necessary.
					</p>
					<p>In all other cases the pzl-component must be registered at least in one of the 
						places
					</p>
					<ul>
						<li>
						local user-defined file
						</li><li>
						in the LocalUser Windows registry (the folder name HKEY_CURRENT_USER)
						</li><li>
							in the LocalMashine Windows registry (the folder name HKEY_LOCAL_MACHINE)
						</li>
					</ul>
					<p><b>Notice.</b> To register pzl-components it is recommended to use the special 
						tools of the pzl-technology. The manual regitration is not recommended.
					</p>
					<p>The pzl-components are registered in the folders of the Windows registry (listed 
						in the file VpPuZzle/System/Packs/pzlDomains.i)
					</p>
					<div dir="ltr"><pre class="source-vip" style="font-size: 95%; color: black; font-family: Verdana,Arial,sans-serif;"><span class="kw1">constants</span>
    registryVPPuZzleAtGlobal_C = <span class="st0">"vp_PuZzle"</span>.<br>    registryComponentsAtGlobal_C = <span class="st0">"vp_PuZzle<span class="es0">\\</span>pzlComponents"</span>.<br>&nbsp;<br>    registryVPPuZzleAtLocalUser_C = <span class="st0">"Software<span class="es0">\\</span>vp_PuZzle"</span>.<br>    registryComponentsAtLocalUser_C = <span class="st0">"Software<span class="es0">\\</span>vp_PuZzle<span class="es0">\\</span>pzlComponents"</span>.<br>    registryRunAble_C = <span class="st0">"RunAble"</span>.</pre>
					</div>
					<p>The constants used for the registration:
					</p>
					<div dir="ltr"><pre class="source-vip" style="font-size: 95%; color: black; font-family: Verdana,Arial,sans-serif;">registryRunAbleTrue_C=<span class="st0">"True"</span>.<br>   registryRunAbleFalse_C=<span class="st0">"False"</span>.</pre>
					</div>
					<h2><a name="Getting_the_information_about_the_component"></a><span class="mw-headline"><span style="font-weight: bold;"></span>Getting the information about the component</span></h2>
					<p>As it was menioned before the following predicates are declared in the interface 
						pzlComponent and these predicates are supported by the pzl-system
					</p>
					<ul>
						<li>
						getContainerVersion() - returns the information about the pzl-container version
						</li><li>
						getContainerName() - returns the information about the name of the 
						file-container, where the given component is placed
						</li><li>
							getClassInfo(className,classVersion) - returns the information about the name 
							and the version of the class pzlComponent
						</li>
					</ul>
					<p>To give the possbility to the external tools to access to the information about <a title="" href="#Constant_componentID_.D0.A1">
							<b>component identifier</b></a>, <a title="" href="#Constant_componentAlias_C"><b>component 
								alias</b></a> è <a title="" href="#Constant_componentMetaInfo_C"><b>comonent 
								metainfo</b></a>, it is recommended to put the clauses listed below to 
						the implementation of the base class of the component:
					</p>
					<div dir="ltr"><pre class="source-vip" style="font-size: 95%; color: black; font-family: Verdana,Arial,sans-serif;"><span class="kw1">clauses</span>
  getComponentID<span class="br0">(</span><span class="br0">)</span>= componentID_C.<br>  getComponentAlias<span class="br0">(</span><span class="br0">)</span> = componentAlias_C.<br>  getComponentMetaInfo<span class="br0">(</span><span class="br0">)</span> = componentMetaInfo_C</pre>
					</div>
					<p>Remind that the declarations of these predicates you can find in the interface 
						pzlComponent.
					</p>
					<h2><a name="Unauthorized_access_restrictions"></a><span class="mw-headline"><span style="font-weight: bold;"></span>Unauthorized access restrictions</span></h2>
					<p>Pzl-componene doesn't contain any facility to restrict it's use. If the program 
						can get an access to the pzl-container, where the pzl-component is placed, and 
						the program knows the interfaces to communicate with the component, then this 
						component is acessible by the program.
					</p>
					<p>Being the author of the component, you may provide the additional arrangements 
						to restrict the rigts to use the pzl-component.
					</p>
					<p>Say, you may provide the special procedure to identify the rights to communicate 
						with the pzl-component.
					</p>
					<p>If the source code of the component is not widely known, then this way of the 
						setting of the safety may be enough efficient.
					</p>
				</div>
			</div>
		</div>
	</body></html>